Node.js實戰  [PDF電子書&原始碼]


資料來源:https://www.books.com.tw/products/CN11502379


目錄
第 一部分 Node基礎知識介紹
第　1 章 歡迎進入Node．js的世界　2
1．1　一個典型的Node Web應用程式　2
1．1．1　非阻塞I/O　3
1．1．2　事件輪詢　4
1．2　ES2015、Node和V8　5
1．2．1　Node與V8　7
1．2．2　使用特性組　8
1．2．3　瞭解Node的發佈計畫　8
1．3　安裝Node　8
1．4　Node自帶的工具　9
1．4．1　npm　9
1．4．2　核心模組　10
1．4．3　調試器　11
1．5　三種主流的Node程式　12
1．5．1　Web應用程式　12
1．5．2　命令列工具和幕後程式　13
1．5．3　桌面程式　14
1．5．4　適合Node的應用程式　14
1．6　總結　15
第　2 章 Node程式設計基礎　16
2．1　Node功能的組織及重用　16
2．2　開始一個新的Node專案　18
2．3　用module．exports微調模組的創建　20
2．4　用node_modules重用模組　22
2．5　注意事項　23
2．6　使用非同步程式設計技術　24
2．7　用回檔處理一次性事件　25
2．8　用事件發射器處理重複性事件　28
2．8．1　事件發射器示例　28
2．8．2　回應只應該發生一次的事件　29
2．8．3　創建事件發射器：一個PUB/SUB的例子　29
2．8．4　擴展事件監聽器：文件監視器　32
2．9　非同步開發的難題　34
2．10　非同步邏輯的順序化　35
2．11　何時使用串列流程控制　36
2．12　實現序列化流程控制　37
2．13　實現並行化流程控制　39
2．14　利用社區裡的工具　41
2．15　總結　43
第　3 章 Node Web程式是什麼　44
3．1　瞭解Node Web程式的結構　45
3．1．1　開始一個新的Web程式　45
3．1．2　跟其他平臺比一比　47
3．1．3　然後呢　47
3．2　搭建一個RESTful Web服務　47
3．3　添加資料庫　50
3．3．1　製作自己的模型API　51
3．3．2　讓文章可讀並把它存起來　53
3．4　添加使用者介面　54
3．4．1　支持多種格式　54
3．4．2　渲染範本　55
3．4．3　用npm管理用戶端依賴項　56
3．5　總結　57
D二部分　Node的Web開發
第　4 章 前端構建系統　60
4．1　瞭解基於Node的前端開發　60
4．2　用npm運行腳本　61
4．2．1　創建定制的npm腳本　62
4．2．2　配置前端構建工具　63
4．3　用Gulp實現自動化　63
4．3．1　把Gulp添加到項目中　64
4．3．2　Gulp任務的創建及運行　64
4．3．3　監測變化　66
4．3．4　在大專案中把任務分散到不同檔中　66
4．4　用Webpack構建Web程式　67
4．4．1　使用打包器和外掛程式　67
4．4．2　配置和運行Webpack　68
4．4．3　用Webpack開發伺服器　68
4．4．4　載入CommonJS模組和靜態資源　70
4．5　總結　71
第　5 章 伺服器端框架　72
5．1　用戶畫像　72
5．1．1　菲爾：代理kai發者　73
5．1．2　納迪娜：開源kai發者　73
5．1．3　愛麗絲：產品kai發者　73
5．2　框架是什麼　74
5．3　Koa　74
5．3．1　設置　76
5．3．2　定義路由　76
5．3．3　REST API　77
5．3．4　優點　77
5．3．5　弱點　77
5．4　Kraken　77
5．4．1　設置　77
5．4．2　定義路由　78
5．4．3　REST API　79
5．4．4　優點　79
5．4．5　弱點　79
5．5　hapi　79
5．5．1　設置　80
5．5．2　定義路由　80
5．5．3　外掛程式81
5．5．4　REST API　82
5．5．5　優點　83
5．5．6　弱點　83
5．6　Sails．js　83
5．6．1　設置　83
5．6．2　定義路由　84
5．6．3　REST API　84
5．6．4　優點　85
5．6．5　弱點　85
5．7　DerbyJS　85
5．7．1　設置　85
5．7．2　定義路由　86
5．7．3　REST API　87
5．7．4　優點　87
5．7．5　弱點　87
5．8　Flatiron．js　87
5．8．1　設置　88
5．8．2　定義路由　88
5．8．3　REST API　89
5．8．4　優點　90
5．8．5　弱點　90
5．9　LoopBack　90
5．9．1　設置　91
5．9．2　定義路由　92
5．9．3　REST API　92
5．9．4　優點　93
5．9．5　弱點　93
5．10　比較　93
5．11　編寫模組化代碼　95
5．12　用戶選擇　95
5．13　總結　95
第　6 章 深入瞭解Connect和Express　96
6．1　Connect　96
6．1．1　創建Connect程式　97
6．1．2　瞭解Connect中介軟體的工作機制　97
6．1．3　組合中介軟體　98
6．1．4　中介軟體的順序　98
6．1．5　創建可配置的中介軟體　99
6．1．6　使用錯誤處理中介軟體　101
6．2　Express　103
6．2．1　生成程式框架　103
6．2．2　Express和程式的配置　107
6．2．3　渲染視圖　109
6．2．4　Express路由入門　113
6．2．5　用戶認證　120
6．2．6　註冊新用戶　124
6．2．7　已註冊用戶登錄　130
6．2．8　用戶載入中介軟體　133
6．2．9　創建REST API　134
6．2．10　啟用內容協商　140
6．3　總結　142
第　7 章 Web程式的範本　143
7．1　用範本保持代碼的整潔性　143
7．2　Embedded JavaScript的範本　147
7．2．1　創建範本　148
7．2．2　將EJS集成到你的程式中　149
7．2．3　在用戶端程式中使用EJS　150
7．3　使用Mustache範本語言與Hogan　151
7．3．1　創建範本　151
7．3．2　Mustache標籤　151
7．3．3　微調Hogan　154
7．4　用Pug做範本　154
7．4．1　Pug基礎知識　155
7．4．2　Pug範本中的邏輯　157
7．4．3　組織Pug範本　159
7．5　總結　163
第　8 章 存儲資料　164
8．1　關係型數據庫　164
8．2　PostgreSQL　164
8．2．1　安裝及配置　164
8．2．2　創建資料庫　165
8．2．3　從Node中連接Postgres　165
8．2．4　定義表　166
8．2．5　插入資料　166
8．2．6　更新資料　166
8．2．7　查詢資料　167
8．3　Knex　167
8．3．1　查詢構建器　168
8．3．2　用Knex實現連接和查詢　168
8．3．3　切換資料庫　170
8．3．4　注意抽象漏洞　171
8．4　MySQL和PostgreSQL　171
8．5　ACID保證　172
8．5．1　原子性：無論成敗，事務必須整體執行　172
8．5．2　一致性：始終確保約束條件　172
8．5．3　隔離性：併發事務不會相互干擾　172
8．5．4　耐用性：事務是永久性的　173
8．6　NoSQL　173
8．7　分散式資料庫　173
8．8　MongoDB　174
8．8．1　安裝和配置　174
8．8．2　連接MongoDB　174
8．8．3　插入文檔　175
8．8．4　查詢　176
8．8．5　使用MongoDB標識　177
8．8．6　使用複製集　178
8．8．7　瞭解寫關注　180
8．9　鍵/值存儲　181
8．10　Redis　181
8．10．1　安裝和配置　182
8．10．2　初始化　182
8．10．3　處理鍵/值對　183
8．10．4　處理鍵　184
8．10．5　編碼與資料類型　184
8．10．6　使用散列表　186
8．10．7　使用列表　186
8．10．8　使用集合　187
8．10．9　用頻道實現發佈/訂閱功能　188
8．10．10　提升性能　189
8．11　嵌入式資料庫　189
8．12　LevelDB　190
8．12．1　LevelUP與LevelDOWN　190
8．12．2　安裝　191
8．12．3　API概覽　191
8．12．4　初始化　191
8．12．5　鍵/值編碼　192
8．12．6　鍵/值對的讀寫　192
8．12．7　可插拔的後臺　193
8．12．8　模組化資料庫　194
8．13　昂貴的序列化和反序列化　195
8．14　流覽器內存儲　196
8．14．1　Web存儲：localStorage和sessionStorage　196
8．14．2　值的讀寫　197
8．14．3　localForage　199
8．14．4　讀和寫　199
8．15　存儲託管　200
8．16　選哪個資料庫　201
8．17　總結　201
第　9 章 測試Node程式　202
9．1　單元測試　203
9．1．1　assert模組　203
9．1．2　Mocha　206
9．1．3　Vows　211
9．1．4　Chai　213
9．1．5　Should．js　214
9．1．6　Sinon．JS的探測器和存根　216
9．2　功能測試　218
9．3　處理失敗的測試　221
9．3．1　獲取更詳細的日誌　221
9．3．2　更好的棧跟蹤　223
9．4　總結　224
第　10 章 Node程式的部署及運維　225
10．1　安置Node程式　225
10．1．1　平臺即服務　226
10．1．2　伺服器　227
10．1．3　容器　228
10．2　部署的基礎知識　229
10．2．1　從Git庫部署　229
10．2．2　保證Node不掉線　230
10．3　線上時長和性能的zui大化　231
10．3．1　用Upstart保證線上時長　232
10．3．2　集群API：充分利用多核處理器　233
10．3．3　靜態檔及代理　235
10．4　總結　236
第三部分　超越Web開發
第　11 章 編寫命令列程式　238
11．1　瞭解慣例和理念　238
11．2　parse-json　239
11．3　使用命令列參數　239
11．3．1　解析命令列參數　239
11．3．2　驗證參數　240
11．3．3　將stdin作為檔傳遞　241
11．4　用npm分享命令列工具　242
11．5　用管道連接腳本　243
11．5．1　將資料通過管道傳給parse-json　243
11．5．2　處理錯誤和退出碼　243
11．5．3　在Node中使用管道　245
11．5．4　管道與命令的執行順序　246
11．6　解釋真正的腳本　247
11．7　總結　247
第　12 章 用Electron征服桌面　248
12．1　認識Electron　248
12．1．1　Electron的技術棧　249
12．1．2　介面設計　250
12．2　創建一個Electron程式　250
12．3　搭建完整的桌面端程式　252
12．3．1　引導React與Babel　253
12．3．2　安裝依賴項　253
12．3．3　設置Webpack　254
12．4　React程式　255
12．4．1　定義Request組件　256
12．4．2　定義Response組件　258
12．4．3　React元件之間的通信　261
12．5　構建與分發　261
12．5．1　用Electron打包器構建程式　261
12．5．2　打包　262
12．6　總結　263
附錄　A 安裝Node　264
附錄　B 自動化的網路抓取　267
附錄　C Connect的官方中介軟體　277
術語表　307
